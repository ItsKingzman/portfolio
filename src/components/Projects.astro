---
import { config } from '../data/config.js';
---

<section id="projects" class="ml-[280px] py-24 bg-[#1a1a1a] overflow-visible">
  <div class="max-w-[1200px] mx-auto px-8">
    <h2 class="section-title text-center mb-16 text-[clamp(2rem,4vw,3rem)] uppercase tracking-wider opacity-0 translate-y-5">
      Projects
    </h2>
    
    <div class="projects-grid grid grid-cols-2 gap-10 max-w-[900px] mx-auto">
      {config.projects.map((project, index) => (
        <article 
          class="project-card group relative bg-[#0a0a0a] rounded-lg overflow-visible border border-[#333] transition-all duration-400 ease-[cubic-bezier(0.4,0,0.2,1)] opacity-0 translate-y-[60px]"
          data-index={index}
        >
          <div class="project-image relative w-full h-[250px] overflow-visible bg-[#2a2a2a] p-5">
            {project.image && (
              <img 
                src={project.image} 
                alt={project.title} 
                loading="lazy"
                class="w-full h-full object-contain transition-transform duration-600 ease-[cubic-bezier(0.4,0,0.2,1)] group-hover:scale-110"
              />
            )}
            <div class="project-overlay absolute inset-0 bg-gradient-to-b from-transparent to-[rgba(10,10,10,0.8)] opacity-0 transition-opacity duration-300 ease-in-out group-hover:opacity-100"></div>
          </div>
          
          <div class="project-content p-8">
            {project.link ? (
              <a href={project.link} target="_blank" rel="noopener" class="no-underline inline-block">
                <h3 class="project-title text-2xl mb-3 text-[#e0e0e0] relative inline-block cursor-pointer transition-colors duration-300 group-hover:text-[#3b82f6]">
                  {project.title}
                  <span class="absolute bottom-[-4px] left-0 w-0 h-0.5 bg-[#3b82f6] transition-all duration-300 group-hover:w-full"></span>
                </h3>
              </a>
            ) : (
              <h3 class="project-title text-2xl mb-3 text-[#e0e0e0] relative inline-block cursor-pointer transition-colors duration-300">
                {project.title}
              </h3>
            )}
            <p class="project-description text-base text-[#a0a0a0] leading-relaxed mb-6">
              {project.description}
            </p>
            
            {project.tags && project.tags.length > 0 && (
              <div class="project-tags flex flex-wrap gap-2 mb-6">
                {project.tags.map(tag => (
                  <span class="project-tag text-xs px-3 py-1.5 bg-[#2a2a2a] text-[#a0a0a0] rounded font-medium transition-all duration-300 group-hover:bg-[#3b82f6] group-hover:text-white group-hover:-translate-y-0.5">
                    {tag}
                  </span>
                ))}
              </div>
            )}
            
            <div class="project-links flex gap-4">
              {project.link && (
                <a href={project.link} target="_blank" rel="noopener" class="project-link flex items-center gap-2 text-sm text-[#3b82f6] font-semibold transition-all duration-300 hover:text-[#2563eb]">
                  <span>View Site</span>
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="transition-transform duration-300 hover:translate-x-1">
                    <path d="M3 8H13M13 8L8 3M13 8L8 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </a>
              )}
              {project.github && (
                <a href={project.github} target="_blank" rel="noopener" class="project-link flex items-center gap-2 text-sm text-[#3b82f6] font-semibold transition-all duration-300 hover:text-[#2563eb]">
                  <span>GitHub</span>
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="transition-transform duration-300 hover:translate-x-1">
                    <path d="M3 8H13M13 8L8 3M13 8L8 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </a>
              )}
            </div>
          </div>
          
          {project.link && (project.previewImage || project.image) && (
            <a 
              href={project.link} 
              target="_blank" 
              rel="noopener" 
              class="project-preview absolute top-0 w-[600px] max-w-[calc(100vw-400px)] h-[400px] max-h-[calc(100vh-100px)] rounded-lg shadow-[0_20px_60px_rgba(0,0,0,0.4)] opacity-0 invisible scale-95 transition-all duration-300 ease-[cubic-bezier(0.4,0,0.2,1)] z-[1000] pointer-events-none overflow-hidden no-underline block"
              data-preview-index={index}
            >
              <img 
                src={project.previewImage || project.image} 
                alt={project.title}
                class="w-full h-full object-contain object-top block"
              />
            </a>
          )}
        </article>
      ))}
    </div>
  </div>
</section>

<style>
  /* Fallback: Show projects if JavaScript fails or is disabled */
  .projects-grid:not(.js-loaded) .project-card {
    opacity: 1;
    transform: translateY(0);
  }
  
  /* Fallback after 2 seconds if JS hasn't loaded */
  @media (prefers-reduced-motion: no-preference) {
    .projects-grid:not(.js-loaded) .project-card {
      animation: fadeInFallback 0.1s ease-out 2s forwards;
    }
  }
  
  @keyframes fadeInFallback {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  /* Card hover effects */
  .project-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 8px;
    padding: 2px;
    background: linear-gradient(135deg, #3b82f6, transparent);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .project-card:hover::before {
    opacity: 1;
  }
  
  .project-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 20px 40px rgba(59, 130, 246, 0.3);
  }
  
  /* Preview positioning - odd cards show preview on left */
  .project-card:nth-child(odd) .project-preview {
    right: calc(100% + 2rem);
    left: auto;
    transform: translateX(20px) scale(0.95);
  }
  
  /* Preview positioning - even cards show preview on right */
  .project-card:nth-child(even) .project-preview {
    left: calc(100% + 2rem);
    right: auto;
    transform: translateX(-20px) scale(0.95);
  }
  
  /* Show preview on card hover */
  .project-card:hover .project-preview {
    opacity: 1;
    visibility: visible;
    transform: translateX(0) scale(1);
    pointer-events: auto;
  }
  
  /* Keep preview visible when hovering over it */
  .project-preview:hover {
    opacity: 1 !important;
    visibility: visible !important;
    transform: translateX(0) scale(1) !important;
    pointer-events: auto !important;
  }
  
  @media (max-width: 1400px) {
    .project-preview {
      width: 500px;
      height: 350px;
    }
  }
  
  @media (max-width: 1200px) {
    .project-preview {
      width: 450px;
      height: 300px;
    }
  }
  
  @media (max-width: 968px) {
    #projects {
      margin-left: 0;
    }
    
    .projects-grid {
      grid-template-columns: 1fr;
      gap: 2rem;
    }
    
    .project-preview {
      display: none;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      const animeModule = await import('animejs');
      const anime = animeModule.default;
      
      const projectsGrid = document.querySelector('.projects-grid');
      
      // Animate section title
      const sectionTitle = document.querySelector('#projects .section-title');
      let titleAnimated = false;
      
      const animateTitle = () => {
        if (titleAnimated || !sectionTitle) return;
        titleAnimated = true;
        anime({
          targets: sectionTitle,
          opacity: [0, 1],
          translateY: [30, 0],
          duration: 1000,
          easing: 'easeOutExpo',
        });
      };
      
      if (sectionTitle) {
        const titleObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              animateTitle();
              titleObserver.unobserve(sectionTitle);
            }
          });
        }, { threshold: 0.1 });
        titleObserver.observe(sectionTitle);
        
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            const rect = sectionTitle.getBoundingClientRect();
            const windowHeight = window.innerHeight || document.documentElement.clientHeight;
            if (rect.top < windowHeight + 200 && rect.bottom > -200) {
              animateTitle();
            }
          });
        });
        
        setTimeout(() => {
          if (!titleAnimated) {
            animateTitle();
          }
        }, 1500);
      }
      
      // Animate project cards
      let hasAnimatedCard = false;
      
      const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -100px 0px'
      };
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target;
            const index = parseInt(card.getAttribute('data-index') || '0');
            
            if (!hasAnimatedCard && projectsGrid) {
              hasAnimatedCard = true;
              projectsGrid.classList.add('js-loaded');
            }
            
            anime({
              targets: card,
              opacity: [0, 1],
              translateY: [60, 0],
              scale: [0.9, 1],
              duration: 1000,
              delay: index * 100,
              easing: 'easeOutCubic',
            });
            
            const tags = card.querySelectorAll('.project-tag');
            if (tags.length > 0) {
              anime({
                targets: tags,
                opacity: [0, 1],
                translateY: [20, 0],
                scale: [0.8, 1],
                duration: 800,
                delay: anime.stagger(100, {start: 600 + index * 150}),
                easing: 'spring(1, 80, 10, 0)',
              });
            }
            
            const links = card.querySelectorAll('.project-link');
            if (links.length > 0) {
              anime({
                targets: links,
                opacity: [0, 1],
                translateX: [-20, 0],
                duration: 800,
                delay: anime.stagger(100, {start: 800 + index * 150}),
                easing: 'easeOutExpo',
              });
            }
            
            observer.unobserve(card);
          }
        });
      }, observerOptions);
      
      const projectCards = document.querySelectorAll('.project-card');
      
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          projectCards.forEach((card) => {
            observer.observe(card);
            
            const rect = card.getBoundingClientRect();
            const windowHeight = window.innerHeight || document.documentElement.clientHeight;
            const isVisible = rect.top < windowHeight + 200 && rect.bottom > -200;
            
            if (isVisible) {
              observer.unobserve(card);
              
              if (!hasAnimatedCard && projectsGrid) {
                hasAnimatedCard = true;
                projectsGrid.classList.add('js-loaded');
              }
              
              const index = parseInt(card.getAttribute('data-index') || '0');
              anime({
                targets: card,
                opacity: [0, 1],
                translateY: [60, 0],
                scale: [0.9, 1],
                duration: 1000,
                delay: index * 100,
                easing: 'easeOutCubic',
              });
            }
          });
          
          setTimeout(() => {
            if (!hasAnimatedCard && projectsGrid) {
              projectsGrid.classList.add('js-loaded');
            }
          }, 2000);
        });
      });
      
      // Preview positioning and hover handling
      projectCards.forEach((card, index) => {
        const preview = card.querySelector('.project-preview');
        if (!preview) return;
        
        let hideTimeout;
        let isHoveringPreview = false;
        
        const showPreview = () => {
          clearTimeout(hideTimeout);
          isHoveringPreview = true;
          positionPreview();
          preview.style.opacity = '1';
          preview.style.visibility = 'visible';
          preview.style.pointerEvents = 'auto';
          preview.style.transform = 'translateX(0) scale(1)';
        };
        
        const hidePreview = () => {
          clearTimeout(hideTimeout);
          hideTimeout = setTimeout(() => {
            if (!isHoveringPreview) {
              preview.style.opacity = '0';
              preview.style.visibility = 'hidden';
              preview.style.pointerEvents = 'none';
            }
          }, 100);
        };
        
        const positionPreview = () => {
          const cardRect = card.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const gap = 32;
          
          // Temporarily make visible to measure
          preview.style.visibility = 'visible';
          preview.style.opacity = '0';
          const previewRect = preview.getBoundingClientRect();
          preview.style.visibility = '';
          preview.style.opacity = '';
          
          preview.style.left = '';
          preview.style.right = '';
          preview.style.top = '';
          
          const isOdd = index % 2 === 0;
          
          if (isOdd) {
            preview.style.right = `calc(100% + ${gap}px)`;
            preview.style.left = 'auto';
            const previewLeft = cardRect.left - previewRect.width - gap;
            if (previewLeft < 20) {
              preview.style.left = `calc(100% + ${gap}px)`;
              preview.style.right = 'auto';
            }
          } else {
            preview.style.left = `calc(100% + ${gap}px)`;
            preview.style.right = 'auto';
            const previewRight = cardRect.right + previewRect.width + gap;
            if (previewRight > viewportWidth - 20) {
              preview.style.right = `calc(100% + ${gap}px)`;
              preview.style.left = 'auto';
            }
          }
          
          const previewTop = cardRect.top;
          const previewBottom = previewTop + previewRect.height;
          
          if (previewBottom > viewportHeight - 20) {
            const overflow = previewBottom - viewportHeight + 20;
            preview.style.top = `${-overflow}px`;
          } else if (previewTop < 20) {
            preview.style.top = `${20 - previewTop}px`;
          }
        };
        
        card.addEventListener('mouseenter', showPreview);
        card.addEventListener('mouseleave', () => {
          isHoveringPreview = false;
          hidePreview();
        });
        
        preview.addEventListener('mouseenter', () => {
          isHoveringPreview = true;
          clearTimeout(hideTimeout);
          showPreview();
        });
        
        preview.addEventListener('mouseleave', () => {
          isHoveringPreview = false;
          hidePreview();
        });
        
        window.addEventListener('resize', () => {
          if (preview.style.opacity === '1') {
            positionPreview();
          }
        });
        
        // Magnetic effect
        card.addEventListener('mousemove', (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          const deltaX = (x - centerX) / centerX;
          const deltaY = (y - centerY) / centerY;
          
          const img = card.querySelector('.project-image img');
          if (img) {
            anime({
              targets: img,
              translateX: deltaX * 10,
              translateY: deltaY * 10,
              duration: 150,
              easing: 'easeOutQuad',
            });
          }
        });
        
        card.addEventListener('mouseleave', () => {
          const img = card.querySelector('.project-image img');
          if (img) {
            anime({
              targets: img,
              translateX: 0,
              translateY: 0,
              duration: 100,
              easing: 'easeOutElastic(1, .6)',
            });
          }
        });
      });
    } catch (error) {
      console.error('Animation error:', error);
      const projectCards = document.querySelectorAll('.project-card');
      projectCards.forEach((card) => {
        card.style.opacity = '1';
        card.style.transform = 'translateY(0)';
      });
      
      const sectionTitle = document.querySelector('.section-title');
      if (sectionTitle) {
        sectionTitle.style.opacity = '1';
        sectionTitle.style.transform = 'translateY(0)';
      }
    }
  });
</script>
