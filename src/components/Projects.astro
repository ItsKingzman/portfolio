---
import { config } from '../data/config.js';
---

<section class="projects section" id="projects">
  <div class="container">
    <h2 class="section-title">Projects</h2>
    
    <div class="projects-grid">
      {config.projects.map((project, index) => (
        <article class="project-card" data-index={index} data-project-link={project.link || ''}>
          <div class="project-image">
            {project.image && (
              <img src={project.image} alt={project.title} loading="lazy" />
            )}
            <div class="project-overlay"></div>
          </div>
          
          <div class="project-content">
            {project.link ? (
              <a href={project.link} target="_blank" rel="noopener">
                <h3 class="project-title">{project.title}</h3>
              </a>
            ) : (
              <h3 class="project-title">{project.title}</h3>
            )}
            <p class="project-description">{project.description}</p>
            
            {project.tags && project.tags.length > 0 && (
              <div class="project-tags">
                {project.tags.map(tag => (
                  <span class="project-tag">{tag}</span>
                ))}
              </div>
            )}
            
            <div class="project-links">
              {project.link && (
                <a href={project.link} target="_blank" rel="noopener" class="project-link">
                  <span>View Site</span>
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M3 8H13M13 8L8 3M13 8L8 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </a>
              )}
              {project.github && (
                <a href={project.github} target="_blank" rel="noopener" class="project-link">
                  <span>GitHub</span>
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M3 8H13M13 8L8 3M13 8L8 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </a>
              )}
            </div>
          </div>
          
          {project.link && (project.previewImage || project.image) && (
            <a href={project.link} target="_blank" rel="noopener" class="project-preview">
              <img src={project.previewImage || project.image} alt={project.title} />
            </a>
          )}
        </article>
      ))}
    </div>
  </div>
</section>

<style>
  .projects {
    margin-left: 280px;
    padding: var(--spacing-xl) 0;
    background: var(--color-bg-secondary);
    overflow: visible;
  }
  
  .section-title {
    text-align: center;
    margin-bottom: 4rem;
    font-size: clamp(2rem, 4vw, 3rem);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    opacity: 0;
    transform: translateY(20px);
  }
  
  .projects-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 2.5rem;
    max-width: 900px;
    margin: 0 auto;
  }
  
  .project-card {
    background: var(--color-bg);
    border-radius: var(--border-radius);
    overflow: visible;
    border: 1px solid var(--color-border);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0;
    transform: translateY(60px);
    position: relative;
  }
  
  /* Fallback: Show projects if JavaScript fails or is disabled */
  .projects-grid:not(.js-loaded) .project-card {
    opacity: 1;
    transform: translateY(0);
  }
  
  /* Fallback after 2 seconds if JS hasn't loaded */
  @media (prefers-reduced-motion: no-preference) {
    .projects-grid:not(.js-loaded) .project-card {
      animation: fadeInFallback 0.1s ease-out 2s forwards;
    }
  }
  
  @keyframes fadeInFallback {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .project-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: var(--border-radius);
    padding: 2px;
    background: linear-gradient(135deg, var(--color-accent), transparent);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .project-card:hover::before {
    opacity: 1;
  }
  
  .project-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 20px 40px rgba(59, 130, 246, 0.3);
  }
  
.project-image {
  position: relative;
  width: 100%;
  height: 250px;
  overflow: visible; /* Changed from hidden */
  background: var(--color-bg-tertiary);
  padding: 20px; /* Add padding */
}

.project-image img {
  width: 100%;
  height: 100%;
  object-fit: contain; /* Changed from cover */
  transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}
  
  .project-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(180deg, transparent 0%, rgba(10, 10, 10, 0.8) 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .project-card:hover .project-overlay {
    opacity: 1;
  }
  
  .project-card:hover .project-image img {
    transform: scale(1.1);
  }
  
  .project-content {
    padding: 2rem;
  }
  
  .project-title {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
    color: var(--color-text);
    position: relative;
    display: inline-block;
    cursor: pointer;
    transition: color 0.3s ease;
  }

  /* Make the parent link inherit styles */
  .project-content > a {
    text-decoration: none;
    display: inline-block;
  }

  .project-content > a:hover .project-title {
    color: var(--color-accent);
  }

  .project-title::after {
    content: '';
    position: absolute;
    bottom: -4px;
    left: 0;
    width: 0;
    height: 2px;
    background: var(--color-accent);
    transition: width 0.3s ease;
  }

  .project-content > a:hover .project-title::after {
    width: 100%;
  }
  
  .project-description {
    font-size: 1rem;
    color: var(--color-text-secondary);
    line-height: 1.6;
    margin-bottom: 1.5rem;
  }
  
  .project-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
  }
  
  .project-tag {
    font-size: 0.75rem;
    padding: 0.4rem 0.8rem;
    background: var(--color-bg-tertiary);
    color: var(--color-text-secondary);
    border-radius: 4px;
    font-weight: 500;
    transition: all 0.3s ease;
  }
  
  .project-card:hover .project-tag {
    background: var(--color-accent);
    color: white;
    transform: translateY(-2px);
  }
  
  .project-links {
    display: flex;
    gap: 1rem;
  }
  
  .project-link {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--color-accent);
    font-weight: 600;
    transition: all 0.3s ease;
  }
  
  .project-link svg {
    transition: transform 0.3s ease;
  }
  
  .project-link:hover {
    color: var(--color-accent-hover);
  }
  
  .project-link:hover svg {
    transform: translateX(4px);
  }
  
  /* Project Preview on Hover */
  .project-preview {
    position: absolute;
    top: 0;
    width: 600px;
    max-width: calc(100vw - 400px);
    height: 400px;
    max-height: calc(100vh - 100px);
    border-radius: var(--border-radius);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1000;
    pointer-events: none;
    overflow: hidden;
    text-decoration: none;
    display: block;
  }
  
  .project-preview img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    object-position: top;
    display: block;
  }
  
  /* Default positioning - will be adjusted by JavaScript */
  .project-card:nth-child(odd) .project-preview {
    right: calc(100% + 2rem);
    left: auto;
    transform: translateX(20px) scale(0.95);
  }
  
  .project-card:nth-child(even) .project-preview {
    left: calc(100% + 2rem);
    right: auto;
    transform: translateX(-20px) scale(0.95);
  }
  
  .project-card:hover .project-preview,
  .project-preview:hover {
    opacity: 1;
    visibility: visible;
    transform: translateX(0) scale(1);
    pointer-events: auto;
  }
  
  
  @media (max-width: 1400px) {
    .project-preview {
      width: 500px;
      height: 350px;
    }
  }
  
  @media (max-width: 1200px) {
    .project-preview {
      width: 450px;
      height: 300px;
    }
  }
  
  @media (max-width: 968px) {
    .projects {
      margin-left: 0;
    }
    
    .projects-grid {
      grid-template-columns: 1fr;
      gap: 2rem;
    }
    
    .project-preview {
      display: none; /* Hide preview on mobile */
    }
  }
</style>

<script>
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // Import anime.js
      const animeModule = await import('animejs');
      const anime = animeModule.default;
      
      // Mark that JavaScript is loaded (only after animations start)
      const projectsGrid = document.querySelector('.projects-grid');
      
      // Animate section title with IntersectionObserver
      const sectionTitle = document.querySelector('#projects .section-title');
      let titleAnimated = false;
      
      const animateTitle = () => {
        if (titleAnimated || !sectionTitle) return;
        titleAnimated = true;
        anime({
          targets: sectionTitle,
          opacity: [0, 1],
          translateY: [30, 0],
          duration: 1000,
          easing: 'easeOutExpo',
        });
      };
      
      if (sectionTitle) {
        const titleObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              animateTitle();
              titleObserver.unobserve(sectionTitle);
            }
          });
        }, { threshold: 0.1 });
        titleObserver.observe(sectionTitle);
        
        // Use requestAnimationFrame to ensure DOM is ready, then check viewport
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Check if already visible with more lenient check
            const rect = sectionTitle.getBoundingClientRect();
            const windowHeight = window.innerHeight || document.documentElement.clientHeight;
            if (rect.top < windowHeight + 200 && rect.bottom > -200) {
              animateTitle();
            }
          });
        });
        
        // Fallback timeout
        setTimeout(() => {
          if (!titleAnimated) {
            animateTitle();
          }
        }, 1500);
      }
      
      // Mark js-loaded after first card animation starts
      let hasAnimatedCard = false;
      
      // Intersection Observer for scroll animations
      const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -100px 0px'
      };
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target;
            const index = parseInt(card.getAttribute('data-index') || '0');
            
            // Mark js-loaded after first animation starts
            if (!hasAnimatedCard && projectsGrid) {
              hasAnimatedCard = true;
              projectsGrid.classList.add('js-loaded');
            }
            
            // Staggered entrance animation - smoother and more polished
            anime({
              targets: card,
              opacity: [0, 1],
              translateY: [60, 0],
              scale: [0.9, 1],
              duration: 1000,
              delay: index * 100,
              easing: 'easeOutCubic',
            });
            
            // Animate tags with bounce effect
            const tags = card.querySelectorAll('.project-tag');
            if (tags.length > 0) {
              anime({
                targets: tags,
                opacity: [0, 1],
                translateY: [20, 0],
                scale: [0.8, 1],
                duration: 800,
                delay: anime.stagger(100, {start: 600 + index * 150}),
                easing: 'spring(1, 80, 10, 0)',
              });
            }
            
            // Animate links
            const links = card.querySelectorAll('.project-link');
            if (links.length > 0) {
              anime({
                targets: links,
                opacity: [0, 1],
                translateX: [-20, 0],
                duration: 800,
                delay: anime.stagger(100, {start: 800 + index * 150}),
                easing: 'easeOutExpo',
              });
            }
            
            observer.unobserve(card);
          }
        });
      }, observerOptions);
      
      // Observe all project cards
      const projectCards = document.querySelectorAll('.project-card');
      
      // Use double requestAnimationFrame for better timing
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          projectCards.forEach((card) => {
            observer.observe(card);
            
            // If card is already in viewport, trigger animation immediately
            const rect = card.getBoundingClientRect();
            const windowHeight = window.innerHeight || document.documentElement.clientHeight;
            const isVisible = rect.top < windowHeight + 200 && rect.bottom > -200;
            
            if (isVisible) {
              observer.unobserve(card);
              
              // Mark js-loaded after first animation starts
              if (!hasAnimatedCard && projectsGrid) {
                hasAnimatedCard = true;
                projectsGrid.classList.add('js-loaded');
              }
              
              const index = parseInt(card.getAttribute('data-index') || '0');
              anime({
                targets: card,
                opacity: [0, 1],
                translateY: [60, 0],
                scale: [0.9, 1],
                duration: 1000,
                delay: index * 100,
                easing: 'easeOutCubic',
              });
            }
          });
          
          // Fallback: Mark js-loaded after 2 seconds if no cards animated
          setTimeout(() => {
            if (!hasAnimatedCard && projectsGrid) {
              projectsGrid.classList.add('js-loaded');
            }
          }, 2000);
        });
      });
      
      // Add magnetic effect on hover and handle preview positioning
      projectCards.forEach((card, index) => {
        const preview = card.querySelector('.project-preview');
        if (!preview) return;
        
        // Function to position preview to prevent overflow
        const positionPreview = () => {
          const cardRect = card.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const gap = 32; // 2rem gap
          
          // Get preview dimensions (use getBoundingClientRect after making it visible temporarily)
          preview.style.visibility = 'visible';
          preview.style.opacity = '0';
          const previewRect = preview.getBoundingClientRect();
          preview.style.visibility = '';
          preview.style.opacity = '';
          
          // Reset positioning
          preview.style.left = '';
          preview.style.right = '';
          preview.style.top = '';
          
          const isOdd = index % 2 === 0; // 0-indexed, so 0,2,4 are "odd" visually
          
          if (isOdd) {
            // Left side card - try to show preview on left
            preview.style.right = `calc(100% + ${gap}px)`;
            preview.style.left = 'auto';
            
            // Check if preview overflows left edge
            const previewLeft = cardRect.left - previewRect.width - gap;
            if (previewLeft < 20) {
              // Overflow left, show on right instead
              preview.style.left = `calc(100% + ${gap}px)`;
              preview.style.right = 'auto';
            }
          } else {
            // Right side card - try to show preview on right
            preview.style.left = `calc(100% + ${gap}px)`;
            preview.style.right = 'auto';
            
            // Check if preview overflows right edge
            const previewRight = cardRect.right + previewRect.width + gap;
            if (previewRight > viewportWidth - 20) {
              // Overflow right, show on left instead
              preview.style.right = `calc(100% + ${gap}px)`;
              preview.style.left = 'auto';
            }
          }
          
          // Adjust vertical position if needed
          const previewTop = cardRect.top;
          const previewBottom = previewTop + previewRect.height;
          
          if (previewBottom > viewportHeight - 20) {
            // Preview would overflow bottom, adjust upward
            const overflow = previewBottom - viewportHeight + 20;
            preview.style.top = `${-overflow}px`;
          } else if (previewTop < 20) {
            // Preview would overflow top, adjust downward
            preview.style.top = `${20 - previewTop}px`;
          }
        };
        
        // Position preview on hover
        card.addEventListener('mouseenter', () => {
          positionPreview();
        });
        
        // Keep preview visible when hovering over it
        preview.addEventListener('mouseenter', () => {
          positionPreview();
        });
        
        // Reposition on window resize
        window.addEventListener('resize', () => {
          if (preview.style.opacity === '1' || preview.style.visibility === 'visible') {
            positionPreview();
          }
        });
        
        // Magnetic effect on card image
        card.addEventListener('mousemove', (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          const deltaX = (x - centerX) / centerX;
          const deltaY = (y - centerY) / centerY;
          
          const img = card.querySelector('.project-image img');
          if (img) {
            anime({
              targets: img,
              translateX: deltaX * 10,
              translateY: deltaY * 10,
              duration: 150,
              easing: 'easeOutQuad',
            });
          }
        });
        
        card.addEventListener('mouseleave', () => {
          const img = card.querySelector('.project-image img');
          if (img) {
            anime({
              targets: img,
              translateX: 0,
              translateY: 0,
              duration: 100,
              easing: 'easeOutElastic(1, .6)',
            });
          }
        });
      });
    } catch (error) {
      // If animation fails, show projects anyway
      console.error('Animation error:', error);
      const projectCards = document.querySelectorAll('.project-card');
      projectCards.forEach((card) => {
        card.style.opacity = '1';
        card.style.transform = 'translateY(0)';
      });
      
      const sectionTitle = document.querySelector('.section-title');
      if (sectionTitle) {
        sectionTitle.style.opacity = '1';
        sectionTitle.style.transform = 'translateY(0)';
      }
    }
  });
</script>